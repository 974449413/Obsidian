# 介绍
---

容器：一种特定类型对象的集合

顺序容器：元素在容器中的位置与加入容器的顺序相对应
- 为程序员提供了控制元素存储和访问顺序的能力

# 9.1 顺序容器概述
---

所有顺序容器都提供了快速访问元素的能力，但它们以下方面的性能不同：
- 向容器添加或删除元素的代价(数组)
- 非顺序访问容器中元素的代价(链表)

其实顺序容器，包含的就是 1 对 1 的数据结构，即数组和链表

顺序容器的类型：
1. 数组
	 - vector：数组
	 - array：固定大小数组
	 - string：针对字符的数组
	 - deque：双端队列
2. 链表
	- list：双向链表
	- forward_list：单向链表

选择容器的基本原则：
- 除非有更好的理由，否则使用 vector
- 如果额外开销很重要，不要使用 list 和 forward_list
- 如果需要随机访问元素，使用 vector 和 deque
- 如果要求在中间插入数据，使用 list 和 forward_list
- 如果需要头尾插入，但不会在中间插入，使用 deque
- 如果只有在读取输入时才在中间插入，之后需要随机访问：
	- 在 vector 中追加数据，然后 sort 函数排序
	- 输入时使用 list，然后将 list 中的内容拷贝到 vector 中

# 9.2 容器库概览
---

一般来说，每个容器都定义在一个头文件中，文件名与类型名相同
- 即容器均定义为模板类
- 即对于大多数容器，我们都需要额外提供元素类型信息

顺序容器可以保存任意类型的元素，甚至是另一个容器

1. 类型别名：即容器中除了定义的容器类型，还定义了其他类型
	- iterator：迭代器
	- const_iterator：只读的迭代器
	- size_type：无符号整数类型，足以保存此容器类型最大容量
	- difference_type：有符号整数类型，足够保存两个迭代器之间的距离
	- value_type：元素类型
	- reference：元素的左值类型，与 value_type& 含义相同
	- const_reference：元素的 const 左值类型，与 const value_type& 含义相同
2. 构造函数
	- C c：构造空容器
	- C c1(c2)：构造 c1，其为 c2 的拷贝
	- C c(b, e)：构造 c，将迭代器 b 和 e 指定的范围内的元素拷贝到 c(array不支持)
	- C c{a, b, c...}：构造 c，并列表初始化
3. 赋值与 swap
	- c1 = c2：将 c1 中的所有元素都替换为 c2 中的元素
	- c1 = {a, b, c...}：将 c1 中的元素都替换为列表中的元素(array不支持)
	- a.swap(b)：交换 a 与 b 的元素
	- swap(a, b)：与 a.swap(b) 等价
4. 大小函数
	- c.size()：c 中元素的数目
	- c.max_size()：c 可保存的最大元素数目
	- c.empty()：若 c 存储了元素，返回 false，否则返回 true
5. 添加/删除元素(不同容器接口不同)
	- c.insert(args)：将 args 中的元素拷贝进 c
	- c.emplace(inits)：使用 inits 构造 c 中的一个元素
	- c.erase(args)：删除 args 指定的元素
	- c.clear()：删除 c 中的所有元素，并返回 void
6. 获取迭代器
	- c.begin()：首元素位置
	- c.end()：尾元素之后的位置
	- c.cbegin()：const 版本
	- c.cend()：const 版本
7. 反向容器的额外成员(不支持 forward_list)
	- reverse_iterator：按逆序寻址元素的迭代器
	- const_reverse_iterator：不能修改元素的逆序迭代器
	- c.rbegin()：尾元素位置
	- c.rend()：首元素之前的位置
	- c.crbegin()：const 版本
	- c.crent()：const 版本

## 9.2.1 迭代器

迭代器通过解引用运算符访问元素，并定义了递增运算符

迭代器的范围：
- 由一对迭代器表示
- 分别指向了同一个容器中的首元素和尾元素之后的位置
- 这个范围被称为左闭合区间：\[begin, end]

左闭合区间的性质：
- 如果 begin 和 end 相等，则范围为空
- 如果 begin 和 end 不等，则范围至少包含一个元素，且 begin 指向该范围中的元素
- 我们可以对 begin 递增若干次，使得 begin == end

## 9.2.2 容器类型成员

类型别名：通过类型别名，我们可以在不了解容器中元素类型的情况下使用它
- value_type：元素的类型
- reference：元素的引用类型

## 9.2.3 begin 和 end 成员

最常用的用途是形成一个包含容器中所有元素的迭代器范围

## 9.2.4 容器定义和初始化

将一个容器初始化为另一个容器的拷贝：
- 直接拷贝整个容器
	- 两个容器的类型和元素类型必须匹配
- 拷贝由一对迭代器指定的元素范围(这些范围都是左闭右开的)
	- 容器类型不必相同
	- 元素类型不必相同，只要能将拷贝的元素转换即可

列表初始化：
- 可以显式的指定容器中每个元素的值
- 对于除 array 之外的容器类型，初始化列表还隐含指定了容器的大小

与顺序容器大小相关的构造函数：只有顺序容器才有
- 一个参数：表示初始化的元素个数，每个元素都是 0 或 空
- 两个参数：第一个参数表示元素个数，第二个参数表示元素的值

标准库 array 具有固定大小：
- 它在初始化的时候，不仅要指定元素类型，还要指定容器大小
- 在使用 array 的其他类型时，也要显式的指定元素类型和大小
- 它可以进行拷贝或对象赋值的操作
	- 内置数组类型不可以

## 9.2.5 赋值和 swap

除了直接赋值和 swap 函数，顺序容器也提供了其特有的赋值操作：
- seq.assign(b, e)：将 seq 中的元素替换为迭代器 b 和 e 所表示范围中的元素；b 和 e 不能指向 seq 自己中的元素
- seq.assign(il)：将 seq 中的元素替换为初始化列表 il 中的元素
- seq.assign(n, t)：将 seq 中的元素替换为 n 个值为 t 的元素

使用 swap 会交换两个相同类型容器的内容：
- 它们只是交换了两个容器的内部数据结构，元素本身并没有被交换
- 除了 string 外，指向容器的迭代器、引用和指针在 swap 操作之后都不会失效，但是这些元素已经属于不同的容器了
	- 元素变了
	- 元素值不变
- 但是对于 array，swap 真的会交换它们的元素，因此它们所需的时间可能会很长，即与 array 中元素的数目成正比
	- 指针、引用、迭代器绑定的元素保持不变，但是元素值被改变了
	- 元素不变
	- 元素值变了

## 9.2.6 容器大小操作

除了一个例外，每个容器类型都提供了三个与大小相关的操作：例外是 forward_list

## 9.2.7 关系运算符

关系运算符的左右运算对象必须是相同类型的容器，且必须保存相同类型的元素：
- 如果两个容器大小相同，且元素两两对应，则这两个容器相等
- 如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器
- 如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果
- 容器的关系运算符是使用元素的关系运算符来完成比较的

# 9.3 顺序容器的操作

