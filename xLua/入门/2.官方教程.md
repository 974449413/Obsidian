# Lua文件加载
---

## 执行字符串

```
luaenv.DoString("print('hello world')")
```

即它执行了Lua内的这串以字符串形式表示的代码，但是不建议这种方式

## 加载Lua文件

使用Lua的require函数即可

```
DoString("require 'byfile'")
```

建议的加载Lua脚本的方式是：整个程序就一个 `DoString("require'main'")` ，然后在main.lua中加载其他的脚本

## 自定义Loader

即我们可以自定义加载器来加载Lua脚本

AddLoader是LuaEnv类中的一个函数，用于添加自定义的加载器。它接受一个 CustomLoader 委托类型的参数，该委托需要返回 byte[] 数组类型，并且可以通过传入 ref string 类型的 filepath 参数来指定要加载的文件路径

当 AddLoader 函数被调用时，xLua 框架会将传入的 loader 委托添加到 Lua 虚拟机实例中，并将其作为默认的 Lua 脚本加载的方式之一。这样，在后续执行 Lua 脚本时，xLua 框架就会自动调用我们自定义的加载器来加载指定的 Lua 文件了

```
public class MyCustomLoader
{
    public byte[] LoadScript(ref string filepath)
    {
        // 在此处编写自定义的Lua脚本加载逻辑，例如从网络或磁盘中加载指定的Lua文件。
        // 返回byte[]数组类型的Lua脚本内容即可。

        return null;
    }
}

// 在LuaEnv中添加自定义加载器
MyCustomLoader customLoader = new MyCustomLoader();
luaenv.AddLoader(customLoader.LoadScript);
```

```
 public delegate byte[] CustomLoader(ref string filepath);
 public void LuaEnv.AddLoader(CustomLoader loader)
```

# C\# 访问Lua
---

这里指的是 C# 主动发起对 Lua 数据结构的访问

## 获取一个全局基本类型数据

访问 LuaEnv.Global 即可，上面有个模板 Get 函数，可指定返回的类型

```
 luaenv.Global.Get<int>("a")
 luaenv.Global.Get<string>("b")
 luaenv.Global.Get<bool>("c")
```

## 访问一个全局的table



# Lua调用C\#
---

## 创建 C# 对象

C#中的创建对象：
```
var newGameObj = new UnityEngine.GameObject();
```

Lua中对应的创建对象：
```
local newGameObj = CS.UnityEngine.GameObject();
```

区别：
1. lua内没有 new 关键字
2. 所有 C# 相关的都放到了 CS 下，包括构造函数，静态成员属性，方法

xLua也支持重载，如：调用GameObject的一个带有string参数的构造函数
```
local newGameObj2 = CS.UnityEngine.GameObject('helloworld')
```

## 访问 C\# 静态属性和静态函数

读取静态属性：
```
CS.UnityEngine.Time.deltaTime
```

写静态属性：
```
CS.UnityEngine.Time.timeScale = 0.5
```

调用静态方法
```
CS.UnityEngine.GameObject.Find('helloworld')
```

小技巧：如果需要经常访问C#中的某一个类，可以先用局部变量引用，然后访问。除了可以减少敲代码的时间，还能提高性能：
```
local GameObject = CS.UnityEngine.GameObject
GameObject.Find('helloworld')
```

## 访问 C\# 成员属性和成员函数

读取成员属性
```
testObj.DMF
```

写成员属性
```
testObj.DMF = 1024
```

调用成员函数：注意，调用成员函数时，第一个参数需要传递该对象，建议使用冒号语法糖
```
testObj:DMFunc()
```

## 访问父类属性和父类函数