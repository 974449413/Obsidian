- OpenGL下的坐标系统
	- OpenGL希望我们在顶点着色器运行完毕之后，将所有顶点的坐标都转化为标准化设备坐标(NDC:Normalized Device Coordinate)
		- 因为在顶点着色器运行完毕后，OpenGL用到的数据只有坐标(gl_Position)，其他数据我们都是传递给片段着色器，让它来进行处理的
	- 我们一般的做法，是定下一个坐标范围，在这个坐标范围内的坐标转化为NDC坐标，在这个坐标范围外的进行裁剪
	- 在进行这个转化的过程中，是以流水线的形式分步进行的，物体的坐标会经历几个过渡矩阵
		- 因为在某些特定的坐标系下，一些操作或运算更加方便和容易
	- 在转化为NDC坐标后，会将其传递给光栅器，将其再转化为屏幕上的二维坐标

# 局部空间(Local Space)

## 局部坐标系

- 物体最初始的坐标就是局部空间中的坐标
	- 可以是任意位置、任意形式的坐标系
	- 物体的坐标向量，都是以这个坐标系来定的

## 模型变换

- 局部空间中的向量，通过模型变换矩阵变换到世界空间坐标系
- 对于三维空间的向量，模型变换矩阵要用四维的齐次矩阵，因为可能存在向量的平移
	- 后续所有的变换矩阵，也都是以齐次的形式来表示的
- 每个物体都有自己独立的局部空间，所以每个物体的模型变换都是不尽相同的
	- 物体的局部空间和世界空间之间的关系是未知的，即也是任意的
	- 所以只有确定了物体的局部空间和世界空间之间的关系，才能确定下模型变换矩阵
	- 确定物体的局部空间和世界空间之间的关系，就是确定物体在世界空间中的位置

# 世界空间(World Space)

## 世界坐标系

- 在经过模型变换后，所有物体都用世界坐标系来表示自身的位置信息了，即它们的坐标系统一了

## 观察变换

- 世界坐标系下的物体，经过观察变换矩阵，得到观察空间下对应的坐标
- 观察矩阵对所有物体来说就是相同的，因为世界坐标系和观察坐标系是一致的

# 观察空间(View Space)

## 观察坐标系

- 观察坐标系下的空间，也被称作是摄像机空间或视觉空间
- 它实际上就是摄像机物体的局部空间
	- 摄像机的位置：原点
	- 摄像机头顶的方向：y 轴正方向
	- 摄像机的朝向：z 轴负方向
- 世界空间变换到观察空间，就是世界坐标系变换到摄像机的局部坐标系中
- 如何确定这个观察变换矩阵呢
	1. 确定局部坐标系
		- 我们规定，这个局部空间的基向量的大小都为1
			- 前提：当我们描述局部空间的基向量时，都是以原先的世界坐标系下的基向量来进行描述的
			- 我们描述时，需要定义基向量的方向和大小
		- 确定摄像机在世界坐标系下的信息
			- 一个是位置向量，即局部坐标系的原点
			- 一个是头顶向量，即局部坐标系的y轴正方向
			- 一个是朝向向量，即局部坐标系的z轴负方向
		- 此时已知原点，y轴，z轴，由右手坐标系(OpenGL)，即可得x轴，即得到了局部坐标系
			- 右手定则的计算：使用叉积即可
	2. 确定观察变换矩阵：其实这个变换就是旋转加上平移
		- 已知 y 轴正方向，z 轴正方向，x 轴正方向
			- 将其化作单位向量(即只表示方向)
			- 然后补四维坐标为0，填入观察变换矩阵
				- 因为它们是一个向量表示方向，所以需要保证向量的方向不变
		- 已知摄像机局部坐标系的原点
			- 补出一个包含第四维度的向量，它携带了 x，y，z 方向的平移信息，并额外赋给了它 w 方向上的额外信息1
		- 通过上述的旋转+平移，即可从世界坐标系转换为摄像机的局部坐标系

## 投影矩阵

### 透视投影矩阵

- 如果不需要透视，可以忽略这个矩阵
- 目的
	1. 我们希望根据 z 值的不同，定义不同的缩放比例
	2. 之前，我们定义了 w 代表整体缩放系数，默认在计算前它是 1
	3. 最后一列向量的前三个分量表示位移
		1. 高维度的错切变换等于低维度的平移
	4. 最后一行的前三个分量表示 x,y,z 对整体缩放的贡献系数，即 分量 * x/y/z = 整体缩放贡献
		1. 如果 x,y,z 都没有共享，就表明只使用了仿射变换，右下角设为 1，表示默认缩放
		2. 如果 x,y,z 有共享(只有一个，否则就不是线性的了)，就表明使用了透视变换，右下角设为 0，表示不使用默认缩放
- 透视投影矩阵的结果，是一个四维向量，只是它第四维表示整体缩放比例

### 正交投影矩阵

- 透视投影矩阵，只是将一个位置向量化为了正交范围内
	- 似乎是透视投影看的东西比正交多
- 无论如何，都要进行正交投影这一步
- 目的：观察空间转换为裁剪空间
	1. 平移
	2. 缩放(NDC坐标)

# 裁剪空间(Clip Space)

## 裁剪的目的

- OpenGL希望定下一个特定的范围，在这个特定的范围之外的点都应该被裁剪掉
	- 如果是图元，其中部分超出了范围，OpenGL会重构这个三角形，使之适合这个裁剪范围
- 然后将这个特定范围内的坐标值，转化为[-1,1]范围内的坐标
	- 相当于以这个特定范围为比例，进行空间的缩放了

## 裁剪坐标系

- 它的基向量方向和观察空间保持不变
- 它的基向量的大小，通过对应的缩放因子(通过裁剪范围得到)进行缩放
- 它的原点在观察空间中裁剪范围的中心，所以需要平移

## 透视除法

- 当转换到裁剪空间后，需要使用透视除法，将四维向量转换为三维向量
	- 在模型变换之前，将三维向量扩充到了四维向量了
- 这步的过程，才是透视的缩放，即它将齐次坐标转换为了三维空间的坐标

## 视口变换

- 它把经过透视除法后，裁剪空间中的 NDC 坐标，转换为屏幕坐标

# 屏幕空间(Screen Space)

## 它对应了就是真实的屏幕中，物体对应的位置关系

---

# 组合

- 步骤
	1. 正交变换 * 透视变换(选) * 观察变换 * 模型变换
	2. 透视除法
	3. 视口变换
- 在相同步骤，将矩阵合并为一个矩阵，便于计算

