# 你好，三角形
---

在OpenGL中，任何物体都是3D的，但是显示的屏幕和窗口都是2D的，这导致OpenGL的大部分工作都是从3D坐标转化为屏幕像素。

3D坐标转化为2D坐标的处理过程是通过OpenGL的图形渲染管线管理的，它主要包含了两个部分：
1. 3D坐标转化为2D坐标
2. 2D坐标转化为实际有颜色的像素

> 图形渲染管线：指的是一堆原始图形数据，经过一个输送管道，期间经过各种变化处理，最终呈现到屏幕上的过程

> 2D坐标和2D像素是不同的：2D坐标精确表示一个点在2D空间中的位置，而2D像素则是这个点的近似值，而且2D像素会受到屏幕或窗口的分辨率限制

图形管线可以被划分为几个阶段，每个阶段都会把前一个阶段的输出作为输入。这些阶段都是高度专门化的，并很容易执行，且具有并行的特性，即适合在GPU中执行，这些阶段运行的小程序被称为着色器

> GPU：弱化但多，适合于执行简单但执行次数非常多的程序

OpenGL的着色器由GLSL语言编写，我们可以在某些阶段自定义着色器代码，从而定制效果：
- 输入顶点数据
1. 顶点着色器(可定制)
2. 图元装配
3. 几何着色器(可定制)
4. 光栅化
5. 片段着色器(可定制)
6. 测试与混合
- 输出像素数据

- 顶点数据：是一系列顶点的集合
	- 顶点：由一系列顶点属性表示，可以包含一个顶点的所有数据(不仅仅是位置)
- 顶点着色器：把一个单独的顶点作为输入，将3D坐标转换为另一种3D坐标，并允许我们对顶点属性进行一些基本处理
- 图元装配：将顶点着色器中的所有顶点输入，并将所有点装配为指定的图元形状
	- 图元：数据渲染的类型，如：点，线，面
		- 点：GL_POINTS
		- 线：GL_LINE_STRIP
		- 面：GL_TRIANGLES
- 几何着色器：把图元映射为屏幕上相应的像素
- 片段着色器：计算一个像素最终的颜色，它是OpenGL产生高级效果的地方
	- 片段：渲染一个像素所包含的所有数据
- Alpha测试和混合阶段：检测片段对应的深度并判断其是否应该被丢弃，检测alpha值并对物体进行混合

我们至少需要定义一个顶点着色器和一个片段着色器，因为GPU中没有默认的顶点着色器和片段着色器。几何着色器是可选的，通常使用它默认的着色器就行了

# 顶点输入
---

OpenGL是一个3D图形库，所以最开始输入的坐标一定都是3D坐标。

OpenGL在处理坐标时，只能处理[-1, 1]范围内的坐标(即OpenGL的可见区域)，其他超过范围的坐标会被舍弃。即我们需要输入在这个范围内的坐标，或者在顶点着色器中将输入的坐标转换为[-1,1]范围内的坐标

> 标准化设备坐标：NDC，即范围在[-1,1]的范围内的坐标

## 定义顶点数据

如果我们希望绘制2D图形，将z值设为0即可

## 发送给顶点着色器

1. 在GPU上创建内存，用于存储我们的顶点数据

我们通过VBO管理这个内存，它会在GPU内存中存储大量的顶点，使用VBO的好处是我们可以一次性的发送大量数据到GPU上，而不是每个顶点发送一次

> CPU发送数据至GPU的速度很慢，所以我们需要一次发送尽可能多的数据

- 它就是一个对象，即可以理解为一个结构体，它管理着这片内存
- 每个对象都有一个独一无二的id
	1. 生成缓冲和对象
	2. 绑定缓冲的类型(即设置状态)
	3. 向GPU发送数据

可以理解为GPU中的内存被分成很多块，每块都绑定一个对象，然后通过对象来操作这块内存。
每次使用OpenGL进行操作的时候，都要先绑定状态。

2. 配置OpenGL如何解释这些内存
3. 指定其如何发送给显卡

# 顶点着色器
---

顶点着色器是几个可编程的着色器之一，现代OpenGL需要我们至少设置一个顶点和一个片段着色器。

- gl_Position：它是顶点着色器的默认输出，我们至少要给它进行赋值，它是vec4类型的变量。
	- 在此着色器中，进行升维
	- 默认可以给第四个分量设置为1.0

在真实的输入数据中，通常都不是标准化设备坐标，所以需要在这里转换为NDC坐标，当然在本示例中不需要。

> 向量：GLSL中的向量为vec+n，n表示为向量的维数

# 编译着色器
---

每次运行OpenGL，都必须从 CPU 发送 着色器源代码至 GPU，所以 shader 都是动态编译的

1. 创建着色器对象
2. 着色器源码附加到着色器对象上
3. 编译