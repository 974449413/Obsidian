# 引言
---

为什么使用二进制？
- 更容易被表示、存储和传输

单个的位不是很有用，我们需要结合起来：以表示任何有限集合的元素
1. 有限个位进行组合
2. 加上某种解释

三种最重要的数字表示：
1. 无符号编码：基于传统的二进制表示法，表示大于或等于零的数字
2. 补码：表示有符号整数最常见的方式
3. 浮点数：表示以 2 为基数的实数的科学计数法

我们是用有限个位来对数字进行编码，问题：
- 溢出：当结果太大以至于无法表示时

整数和浮点数不同的性质：
- 整数：无论是否溢出，都有交换律和结合律
- 浮点数：无论是否溢出，都没有结合律(因为它的精度有限)

# 2.1 信息存储
---

一些基本的概念：
1. byte：8 位，最小的可寻址内存单位
2. 虚拟内存：一个非常大的字节数组
3. 地址：字节数组的下标
4. 虚拟地址空间：字节数组下标的取值范围

存储的信息：
1. 程序数据
2. 指令
3. 控制信息

分配和管理内存：完全在虚拟地址空间内完成

## 2.1.1 十六进制表示法
---

对于字节来说想要表示位，二进制的表示过于冗长，十进制和二进制又不好相互转化，所以我们引入了十六进制来表示位模式

二进制和十六进制的相互转化：
- 每四个二进制视为一个十六进制即可

## 2.1.2 字数据的大小

字长： CPU 一次处理的数据的大小
- 指明指针数据的大小，即虚拟内存空间的大小
- 指针就是地址
- 对于字长 w 位的机器来说，它的访问范围就是 0 ~ $2^w-1$

因为 CPU 一次处理的数据有限，所以如果一次全部用来寻址，那么它的寻址范围就是 CPU 一次处理的数据的范围，这就是字长

32 位程序指的是编译方式，即它只使用 32 位的虚拟内存空间大小，所以 64 位机器也可以运行 32 位机器编译的程序

除了 char ，只有前面加 unsigned 的才是无符号数，否则都是有符合的：
- char 类型的行为不确定

## 2.1.3 寻址和字节顺序

如果一个对象跨越了多个字节：
1. 定义它的起始地址
2. 确定它的大小
3. 定义它内部是如何排列这些字节的
	- 小端法：低尾端，即尾部在小地址
	- 大端法：高尾端，即尾部在大地址

## 2.1.4 表示字符串

字符串：一个以 null 字符结尾的字符数组
- null：编码位为 0

且每个字符都由某个标准编码来表示，常见的是 ASCII 字符码
- 即存储的是编码
- 使用时将这个编码，转换为对应的字符

## 2.1.5 表示代码

从机器的角度来看，程序仅仅是一个字节序列

## 2.1.6 布尔代数简介

它定义的是一种以位为最小单位的运算：
1. 与：都真为真
2. 或：有真为真
3. 非(一元)：假为真
4. 异或：相反为真

## 2.1.7 C 语言中的位级运算

## 2.1.8 C 语言中的逻辑运算

逻辑运算：它针对的是任何一个数，而非位
- 当逻辑运算的单位是一个位时，它才和位运算等级

逻辑运算的另一个特性：
- 从左往右计算，当已经确定结果时，就不会向下继续计算了
- 即如果在逻辑与运算中，左边已经是 false，它就不会再去计算右边，而会直接返回 false

## 2.1.9 C 语言中的移位运算

移位运算：
1. 左移：补 0 即可
2. 右移：有两种方式
	- 逻辑右移：补 0，它是针对 ***无符号*** 数进行的
	- 算术右移：补最高有效位的值，它是针对 ***有符号*** 数进行的

# 2.2 整数表示

整数表示有两种方式：
1. 无符号数：非负数
2. 有符号数：负数 + 零 + 正数

## 2.2.1 整型数据类型

特点：
1. 不同的数据类型，差别仅仅是表示的范围不相同
2. 如果是有符号数，它表示的范围并不是对称的，即负数的范围比正数的取值范围大 1

## 2.2.2 无符号数的编码

直接编码即可

在取值范围内的任何一个数，它都有唯一一个 $w$ 位的值编码

## 2.2.3 补码编码

有符号数通常用补码来进行编码：
1. 正数和负数的加法采用同样的方式进行
2. 每个数都有唯一的补码
3. 表示了范围更广的整数值

有符号数的三种表示方法：最高位都永远表示符号
1. 原码：最高位为符号位，其他位直接编码
2. 反码：
	- 正数：等于原码
	- 负数：先表示出它的绝对值，然后所有位取反
3. 补码：
	- 正数：等于原码
	- 负数：先表示出它的绝对值，然后所有位取反，然后再加 1

为什么补码表示的有符号数，负数范围比正数范围大 1：
1. 如果把补码看作是无符号数：
	- 正数：补码越大，数越大
	- 负数：补码越大，数越小


```
0000 -> 0
0001 -> 1
0010 -> 2
0011 -> 3
0100 -> 4
0101 -> 5
0110 -> 6
0111 -> 7
1000 -> -8
1001 -> -7
1010 -> -6
1011 -> -5
1100 -> -4
1101 -> -3
1110 -> -2
1111 -> -1

```


